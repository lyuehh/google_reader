<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>cglib源码学习交流</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/google_reader/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/google_reader/css/main.css">

    </head>
    <body>

        <div class="container">
          <div class="site">
            <div class="header">
              <h1 class="title"><a href="/google_reader/">Google Reader</a></h1>
              <a class="extra" href="/google_reader/">home</a>
            </div>

                <h2>cglib源码学习交流</h2>
<p class="meta">2010-11-02 01:16</p>

<div class="post">
<h2>cglib源码学习交流</h2>

<h3>by</h3>

<h3>at 2010-11-01 17:16:36</h3>

<h3>original <a href="http://www.javaeye.com/topic/799827">http://www.javaeye.com/topic/799827</a></h3>

<h2>
<a name="cglib%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E8%83%8C%E6%99%AF"></a>背景</h2>


<p>    前段时间在工作中，包括一些代码阅读过程中，spring aop经常性的会看到cglib中的相关内容，包括BeanCopier,BulkBean,Enancher等内容，以前虽大致知道一些内容，原理是通过bytecode，但没具体深入代码研究，只知其所用不知其所以然，所以就特地花了半天多的工作时间研究了CGLIB的相关源码，同时结合看了下 spring Aop中对CGLIB的使用。</p>


<p>    本文主要通过对cglib有原理的分析，反编译查看源码，例子等方式做一个介绍。</p>


<h1>cglib基本信息</h1>


<ol>
<li>cglib的官方网站： <span><a rel="nofollow" href="http://cglib.sourceforge.net/">http://cglib.sourceforge.net/<sup><img src="http://www.iteye.com/images/icons/linkext7.gif" border="0" alt="" width="7" height="7"></sup></a></span> </li>
<li>cglib目前的最新版本应该是2.2，公司普遍使用的版本也是这个 </li>
<li>官网的samples : <span><a rel="nofollow" href="http://cglib.sourceforge.net/xref/samples/">http://cglib.sourceforge.net/xref/samples/<sup><img src="http://www.iteye.com/images/icons/linkext7.gif" border="0" alt="" width="7" height="7"></sup></a></span> </li>
</ol>


<h1>
<a name="cglib%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-cglib%E6%80%BB%E4%BD%93%E7%BB%93%E6%9E%84"></a>cglib代码包结构</h1>


<ul>
<li>core (核心代码) 
<ul>
<li>EmitUtils </li>
<li>ReflectUtils </li>
<li>KeyFactory </li>
<li>ClassEmitter/CodeEmitter </li>
<li>NamingPolicy/DefaultNamingPolicy </li>
<li>GeneratorStrategy/DefaultGeneratorStrategy </li>
<li>DebuggingClassWriter </li>
<li>ClassGenerator/AbstractClassGenerator </li>
</ul>
</li>
<li>beans (bean操作类) 
<ul>
<li>BeanCopier </li>
<li>BulkBean </li>
<li>BeanMap </li>
<li>ImmutableBean </li>
<li>BeanGenerator </li>
</ul>
</li>
<li>reflect 
<ul>
<li>FastClass </li>
</ul>
</li>
<li>proxy 
<ul>
<li>Enhancer </li>
<li>CallbackGenerator </li>
<li>Callback 
<ul>
<li>
<span style="color:#ff0000">MethodInterceptor</span> , Dispatcher, LazyLoader , ProxyRefDispatcher , NoOp , FixedValue , InvocationHandler(提供和jdk proxy的功能) </li>
</ul>
</li>
<li>CallbackFilter </li>
</ul>
</li>
<li>util 
<ul>
<li>StringSwitcher  </li>
<li>ParallelSorter  </li>
</ul>
</li>
<li>transform  </li>
</ul>


<h1>core核心代码部分</h1>


<h3>
<a name="cglib%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-EmitUtils"></a>EmitUtils</h3>


<p>重要的工具类，主要封装了一些操作bytecode的基本函数，比如生成一个null_constructor，添加类属性add_property等</p>


<h3>
<a name="cglib%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-ReflectUtils"></a>ReflectUtils</h3>


<p>处理jdk reflect的工具类，比如获取一个类所有的Method，获取构造函数信息等。</p>


<h3>
<a name="cglib%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-ClassEmitter%2FCodeEmitter"></a>ClassEmitter/CodeEmitter</h3>


<p>对asm的classAdapter和MethodAdapter的实现，贯穿于cglib代码的处理</p>


<h3>
<a name="cglib%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-KeyFactory"></a>KeyFactory</h3>


<p>类库中重要的唯一标识生成器，用于cglib做cache时做map key，比较底层的基础类。<br>例子：</p>


<div style="border-top-width:1px;border-left-width:1px;border-bottom-width:1px;border-right-width:1px">
<div>
<pre><span>interface</span> BulkBeanKey {
<span>public</span> <span>Object</span> newInstance(<span>String</span> target, <span>String</span>[] getters, <span>String</span>[] setters, <span>String</span>[] types);
}
(BulkBeanKey)KeyFactory.create(BulkBeanKey.class).newInstance(targetClassName, getters, setters, typeClassNames)；</pre>
</div>
</div>


<p>说明：</p>


<ul>
<li>每个Key接口，都必须提供newInstance方法，但具体的参数可以随意定义，通过newInstance返回的为一个唯一标示，只有当传入的所有参数的equals都返回true时，生成的key才是相同的，这就相当于多key的概念。 </li>
</ul>


<h3>
<a name="cglib%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-NamingPolicy"></a>NamingPolicy</h3>


<p>默认的实现类：DefaultNamingPolicy， 具体cglib动态生成类的命名控制。<br>一般的命名规则： </p>


<ul>
<li>被代理class name + "$$" + 使用cglib处理的class name + "ByCGLIB" + "$$" + key的hashcode </li>
<li>示例：<span style="color:#ff0000">FastSource</span>$$<span style="color:#ff0000">FastClass</span>ByCGLIB$$e1a36bab.class </li>
</ul>


<h3>
<a name="cglib%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-GeneratorStrategy"></a>GeneratorStrategy</h3>


<p>默认的实现类：　DefaultGeneratorStrategy<br>控制ClassGenerator生成class的byte数据，中间可插入自己的处理。注意这里依赖了：DebuggingClassWriter进行class generator的处理</p>


<h3>
<a name="cglib%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-DebuggingClassWriter"></a>DebuggingClassWriter</h3>


<p>cglib封装asm的处理类，用于生成class的byte流，通过GeneratorStrategy回调ClassGenerator.generateClass(DebuggingClassWriter)，将自定义的class byte处理回调给具体的cglib上层操作类，比如由具体的BeanCopier去控制bytecode的生成。</p>


<h3>
<a name="cglib%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-ClassGenerator"></a>ClassGenerator</h3>


<p>其中一个抽象实现：AbstractClassGenerator。cglib代码中核心的Class bytecode操作主体，包含了一些cache，调用NamingPolicy,GeneratorStrategy进行处理，<span style="color:#ff0000">可以说是一个最核心的调度者。</span></p>


<p> </p>


<p> </p>


<h2>对应的类图：<br><img src="http://dl.javaeye.com/upload/attachment/341052/092dcafb-db5d-34e7-b91e-8ba43972747a.png" alt=""><br> </h2>


<ol>
<li>外部的BeanCopier都包含了一Generator，继承自AbstractClassGenerator,实现了generateClass(ClassVisitor v),Object firstInstance(Class type)方法。 </li>
<li>AbstractClassGenerator自身会根据Source进行cache，所以针对已经生成过的class，这里KeyFactory对应的值要相等，则会直接返回cache中的结果。<span style="color:#ff0000">所以BeanCopier每次create慢只是每次都需要new两个对象，一个是KeyFactory.newInstance，另一个是firstInstance方法调用生成一个对象。</span> </li>
</ol>


<h1>反编译tips </h1>


<p>大家都知道cglib是进行bytecode操作，会动态生成class，最快最直接的学习就是结合他生成的class，对照代码进行学习，效果会好很多。</p>


<pre name="code">system.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, "指定输出目录");　</pre>


<p> 可参见 cores/DebuggingClassWriter代码。说明：这样cglib会将动态生成的每个class都输出到文件中，然后我们可以通过<span style="color:#ff0000">decomp</span>进行反编译查看源码。</p>


<p> </p>


<h1>
<a name="cglib%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-beans%E3%80%80%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%E7%B1%BB"></a>beans　(相关操作类)</h1>


<h3>
<a name="cglib%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-BeanCopier"></a>BeanCopier</h3>


<p>简单的示例代码就不做介绍，相信大家都指导怎么用，这里主要介绍下Convert的使用。</p>


<ul>
<li>
<span style="color:#ff0000">许多网友都做过BeanCopier，BeanUtils的测试，基本BeanCopier的性能是BeanUtils的10倍以上。</span>，出了反射这一性能差异外，BeanUtils默认是开启Converter功能，允许同名，不同类型的属性进行拷贝，比如Date对象到String属性。 </li>
<li>有兴趣的同学可以去比较下PropertyUtils，默认不开启Converter功能，发现性能是BeanUtils的2倍多。 </li>
</ul>


<p>初始化例子：BeanCopier copier = BeanCopier.create(Source.class, Target.class, true); <br>第三个参数useConverter，是否开启Convert，默认BeanCopier只会做同名，同类型属性的copier，否则就会报错。</p>


<pre name="code">public class BeanCopierTest {

    public static void main(String args[]) {
        System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, "/tmp/1");
        BeanCopier copier = BeanCopier.create(Source.class, Target.class, true);
        Source from = new Source();
        from.setValue(1);

        Target to = new Target();
        Converter converter = new BigIntConverter();
        copier.copy(from, to, converter); //使用converter类

        System.out.println(to.getValue());
    }
}

class BigIntConverter implements net.sf.cglib.core.Converter {

    @Override
    public Object convert(Object value, Class target, Object context) {
        System.out.println(value.getClass() + " " + value); // from类中的value对象
        System.out.println(target); // to类中的定义的参数对象
        System.out.println(context.getClass() + " " + context); // String对象,具体的方法名
        if (target.isAssignableFrom(BigInteger.class)) {
            return new BigInteger(value.toString());
        } else {
            return value;
        }
    }

}
----
反编译后看的代码：
public class Target$$BeanCopierByCGLIB$$e1c34377 extends BeanCopier
{
    public void copy(Object obj, Object obj1, Converter converter)
    {
        Target target = (Target)obj1;
        Source source = (Source)obj;
        // 注意是直接调用，没有通过reflect
        target.setValue((BigInteger)converter.convert(new Integer(source.getValue()), CGLIB$load_class$java$2Emath$2EBigInteger, "setValue")); 
    }
}</pre>


<p> </p>


<h2>使用注意</h2>


<ol>
<li>避免每次进行BeanCopier.create创建对象，一般建议是通过static BeanCopier copier = BeanCopier.create() </li>
<li>合理使用converter。 </li>
<li>应用场景：两个对象之间同名同属性的数据拷贝, <span style="color:#ff0000">不能单独针对其中的几个属性单独拷贝</span> </li>
</ol>


<h2>BulkBean</h2>


<p>     相比于BeanCopier，BulkBean将整个Copy的动作拆分为getPropertyValues，setPropertyValues的两个方法，允许自定义处理的属性。</p>


<p> </p>


<pre name="code">public class BulkBeanTest {

    public static void main(String args[]) {
        System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, "/home/ljh/cglib");
        String[] getter = new String[] { "getValue" };
        String[] setter = new String[] { "setValue" };
        Class[] clazzs = new Class[] { int.class };

        BulkBean bean = BulkBean.create(BulkSource.class, getter, setter, clazzs);
        BulkSource obj = new BulkSource();
        obj.setValue(1);

        Object[] objs = bean.getPropertyValues(obj);
        for (Object tmp : objs) {
            System.out.println(tmp);
        }
    }
}
class BulkSource {
    private int value;
    .....
}

// 反编译后的代码：　
 public void getPropertyValues(Object obj, Object aobj[])
    {
        BulkSource bulksource = (BulkSource)obj;
        aobj[0] = new Integer(bulksource.getValue());
    }</pre>


<p> </p>


<h2>使用注意</h2>


<ol>
<li>避免每次进行BulkBean.create创建对象，一般建议是通过static BulkBean.create copier = BulkBean.create </li>
<li>应用场景：针对特定属性的get,set操作，一般适用通过xml配置注入和注出的属性，运行时才确定处理的Source,Target类，只需关注属性名即可。 </li>
</ol>


<p> </p>


<h3>
<a name="cglib%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-BeanMap"></a>BeanMap</h3>


<p>相比于BeanCopier,BulkBean，都是针对两个Pojo Bean进行处理，那如果对象一个是Pojo Bean和Map对象之间，那就得看看BeanMap，将一个java bean允许通过map的api进行调用。<br>几个支持的操作接口：</p>


<ul>
<li>Object get(Object key) </li>
<li>Object put(Object key, Object value) </li>
<li>void putAll(Map t) </li>
<li>Set entrySet() </li>
<li>Collection values() </li>
<li>boolean containsKey(Object key) </li>
<li>....<br>
</li>
</ul>


<pre name="code">public class BeanMapTest {

    public static void main(String args[]) {
        // 初始化
        BeanMap map = BeanMap.create(new Pojo());
        // 构造
        Pojo pojo = new Pojo();
        pojo.setIntValue(1);
        pojo.setBigInteger(new BigInteger("2"));
        // 赋值
        map.setBean(pojo);
        // 验证
        System.out.println(map.get("intValue"));
        System.out.println(map.keySet());
        System.out.println(map.values());
    }
}

class Pojo {

    private int        intValue;
    private BigInteger bigInteger;
    ....
}

//反编译代码查看：
//首先保存了所有的属性到一个set中
private static FixedKeySet keys = new FixedKeySet(new String[] {
        "bigInteger", "intValue"
    });
public Object get(Object obj, Object obj1)
    {
        (Pojo)obj;
        String s = (String)obj1;
        s;
        s.hashCode();
        JVM INSTR lookupswitch 2: default 72
    //                   -139068386: 40
    //                   556050114: 52;
           goto _L1 _L2 _L3
_L2:
        "bigInteger";
　//属性判断是否相等
        equals();
        JVM INSTR ifeq 73;
           goto _L4 _L5
_L5:
        break MISSING_BLOCK_LABEL_73;
_L4:
        getBigInteger();
        return;
_L3:

....

}</pre>


<p> </p>


<p><strong></strong></p>


<h2>使用注意</h2>


<ol>
<li>避免每次进行BeanMap map = BeanMap.create();创建对象，不同于BeanCopier对象，BeanMap主要针对对象实例进行处理，所以一般建议是map.setBean(pojo);进行动态替换持有的对象实例。 </li>
<li>应用场景：针对put,putAll操作会直接修改pojo对象里的属性，所以可以通过beanMap.putAll(map)进行map&lt;-&gt;pojo属性的拷贝。</li>
</ol>


<p> </p>


<h2>
<a name="cglib%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-BeanGenerator"></a>BeanGenerator</h2>


<p>   暂时没有想到合适的使用场景，不过BeanGenerator使用概念是很简单的，就是将一个Map&lt;String,Class&gt;properties的属性定义，动态生成一个pojo bean类。</p>


<p> </p>


<pre name="code">BeanGenerator generator = new BeanGenerator();
generator.addProperty("intValue", int.class);
generator.addProperty("integer", Integer.class);
generator.addProperty("properties", Properties.class);
       
Class clazz = (Class) generator.createClass();
Object obj = generator.create();

PropertyDescriptor[] getters = ReflectUtils.getBeanGetters(obj.getClass());
for (PropertyDescriptor getter : getters) {
    Method write = getter.getWriteMethod();
    System.out.println(write.getName());
}</pre>


<p> </p>


<h2>
<a name="cglib%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-ImmutableBean"></a>ImmutableBean </h2>


<p>bean Immutable模式的一种动态class实现，Immutable模式主要应用于服务设计上，返回的pojo bean对象，不运行进行write方法调用。</p>


<p> </p>


<p> </p>


<table border="0"><tbody><tr>
<td>
<strong>说明</strong><br><p>个人是不太建议使用cglib动态class的方式来实现bean Immutable的模式，Immutable模式应该是一种服务接口上的显示声明，而不是如此隐晦，而且pojo bean尽量做到是轻量级，简答的set/get方法，如果要做充血的领域模型那就另当别论了。</p>
</td>
</tr></tbody></table>


<p> </p>


<h1>
<a name="cglib%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-reflect%28class%2Cmethod%E5%A4%84%E7%90%86%29"></a>reflect (class,method处理)</h1>


<h2>
<a name="cglib%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-FastClass"></a>FastClass</h2>


<p>顾明思义，FastClass就是对Class对象进行特定的处理，比如通过数组保存method引用，因此FastClass引出了一个index下标的新概念，比如getIndex(String name, Class[] parameterTypes)就是以前的获取method的方法。<br>通过数组存储method,constructor等class信息，从而将原先的反射调用，转化为class.index的直接调用，从而体现所谓的FastClass。</p>


<pre name="code">public class FastClassTest {
    public static void main(String args[]) throws Exception {
        System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, "/home/ljh/cglib");

        FastClass clazz = FastClass.create(FastSource.class);
        // fast class反射调用
        FastSource obj = (FastSource) clazz.newInstance();
        clazz.invoke("setValue", new Class[] { int.class }, obj, new Object[] { 1 });
        clazz.invoke("setOther", new Class[] { int.class }, obj, new Object[] { 2 });

        int value = (Integer) clazz.invoke("getValue", new Class[] {}, obj, new Object[] {});
        int other = (Integer) clazz.invoke("getOther", new Class[] {}, obj, new Object[] {});
        System.out.println(value + " " + other);
        // fastMethod使用
        FastMethod setValue = clazz.getMethod("setValue", new Class[] { int.class });
        System.out.println("setValue index is : " + setValue.getIndex());

        FastMethod getValue = clazz.getMethod("getValue", new Class[] {});
        System.out.println("getValue index is : " + getValue.getIndex());

        FastMethod setOther = clazz.getMethod("setOther", new Class[] { int.class });
        System.out.println("setOther index is : " + setOther.getIndex());

        FastMethod getOther = clazz.getMethod("getOther", new Class[] {});
        System.out.println("getOther index is : " + getOther.getIndex());
        // 其他
        System.out.println("getDeclaredMethods : " + clazz.getJavaClass().getDeclaredMethods().length);
        System.out.println("getConstructors : " + clazz.getJavaClass().getConstructors().length);
        System.out.println("getFields : " + clazz.getJavaClass().getFields().length);
        System.out.println("getMaxIndex : " + clazz.getMaxIndex());
    }
}

class FastSource {
    private int value;
    private int other;

}</pre>


<p> </p>


<h1>
<a name="cglib%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-proxy%28springaop%E7%9B%B8%E5%85%B3%29"></a>proxy (spring aop相关)</h1>


<p>总体类结构图：<br><img src="http://dl.javaeye.com/upload/attachment/341054/0e0d7e2a-7aa4-3455-8445-763b9858a80d.png" alt=""></p>


<h3>
<a name="cglib%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-Callback%26CallbackGenerator"></a>Callback &amp; CallbackGenerator</h3>


<ol>
<li>MethodInterceptor 
<ul>
<li>类似于spring aop的around Advise的功能，大家都知道，不多做介绍。唯一需要注意的就是proxy.invokeSuper和proxy.invoke的区别。invokeSuper是退出当前interceptor的处理，进入下一个callback处理，invoke则会继续回调该方法，<span style="color:#ff0000">如果传递给invoke的obj参数出错容易造成递归调用</span> </li>
</ul>
</li>
<li>Dispatcher, ProxyRefDispatcher 
<ul>
<li>类似于delegate的模式，直接将请求分发给具体的Dispatcher调用，是否有着接口+实现分离的味道，将接口的方法调用通过Dispatcher转到实现target上。ProxyRefDispatcher与Dispatcher想比，loadObject()多了个当前代理对象的引用。 </li>
<li>
<pre name="code">//反编译的部分代码
public final int cal(int i, int j)
{
        CGLIB$CALLBACK_1;
        if(CGLIB$CALLBACK_1 != null) goto _L2; else goto _L1
_L1:
        JVM INSTR pop ;
        CGLIB$BIND_CALLBACKS(this);
        CGLIB$CALLBACK_1;
_L2:
        loadObject(); //每次都进行调用
        (DefaultCalcService);
        i;
        j;
        cal(); //调用实现类的方法
        return;
    } </pre>
</li>
</ul>
</li>
<li>LazyLoader 
<ul>
<li>相比于Dispatcher,lazyLoader在第一次获取了loadObject后，会进行缓存，后续的请求调用都会直接调用该缓存的属性. </li>
<li>
<pre name="code">//反编译部分代码
public final int cal(int i, int j)
{
    this;
    return ((DefaultCalcService)CGLIB$LOAD_PRIVATE_3()).cal(i, j);
}

private final synchronized Object CGLIB$LOAD_PRIVATE_3()
{
        CGLIB$LAZY_LOADER_3; //保存的属性
        if(CGLIB$LAZY_LOADER_3 != null) goto _L2; else goto _L1
_L1:
        JVM INSTR pop ;
        this;
        CGLIB$CALLBACK_3;
        if(CGLIB$CALLBACK_3 != null) goto _L4; else goto _L3
_L3:
        JVM INSTR pop ;
        CGLIB$BIND_CALLBACKS(this);
        CGLIB$CALLBACK_3;
_L4:
        loadObject();
        JVM INSTR dup_x1 ;
        CGLIB$LAZY_LOADER_3;
_L2:
        return;
    }</pre>
</li>
</ul>
</li>
<li>NoOp 
<ul>
<li>不做任何处理，结合Filter针对不需要做代理方法直接返回，调用其原始方法 </li>
</ul>
</li>
<li>FixedValue 
<ul>
<li>强制方法返回固定值,可结合Filter进行控制 </li>
</ul>
</li>
<li>InvocationHandler(提供和jdk proxy的功能),不常用 </li>
</ol>


<h2>CallbackFilter</h2>


<p>主要的作用就是callback调度，主要的一个方法：int accept(Method method); <br>返回的int在int值，代表对应method需要插入的callback，会静态生成到class的代码中，这样是cglib proxy区别于jdk proxy的方式，一个是静态的代码调用，一个是动态的reflect。<br><span style="color:#ff0000">可以查看： Enhancer类中的emitMethods方法，line:883。在构造class method字节吗之前就已经确定需要运行的callback。</span></p>


<p> </p>


<h2>
<a name="cglib%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-Enhancer"></a>Enhancer</h2>


<pre name="code">System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, "/home/ljh/cglib");
LogInteceptor logInteceptor = new LogInteceptor();
CalDispatcher calDispatcher = new CalDispatcher();
CalcProxyRefDispatcher calcProxyRefDispatcher = new CalcProxyRefDispatcher();
LazyLoaderCallback lazyLoaderCallback = new LazyLoaderCallback();

Enhancer enhancer = new Enhancer();
enhancer.setSuperclass(CalcService.class); //接口类
enhancer.setCallbacks(new Callback[] { logInteceptor, calDispatcher, calcProxyRefDispatcher,lazyLoaderCallback, NoOp.INSTANCE }); // callback数组
enhancer.setCallbackFilter(new CalcCallbackFilter()); // filter
CalcService service = (CalcService) enhancer.create();

int result = service.cal(1, 1);</pre>


<p> </p>


<h1>Util  (工具类，感觉有点鸡肋)</h1>


<ul>
<li>StringSwitcher 提供string和int的map映射查询，给定一个string字符串，返回同个下标数组的int值，<span style="color:#ff0000">感觉很鸡肋，用Map不是可以很快速的实现功能</span> </li>
<li>ParallelSorter 看了具体的代码，没啥意思，就是提供了一个二分的快速排序和多路归并排序。没有所谓的并行排序，<span style="color:#ff0000">原本以为会涉及多线程处理，可惜没有</span> </li>
</ul>


<p> </p>


<h1>transform </h1>


<p>     暂时没仔细研究，更多的是对asm的封装，等下次看了asm代码后再回来研究下。</p>


<pre><code>      &lt;br&gt;&lt;br&gt;
      作者: &lt;a href="http://agapple.javaeye.com"&gt;agapple&lt;/a&gt; 
      &lt;br&gt;
      声明: 本文系JavaEye网站发布的原创文章，未经作者书面许可，严禁任何网站转载本文，否则必将追究法律责任！
      &lt;br&gt;&lt;br&gt;
      &lt;span style="color:red"&gt;
        &lt;a href="http://www.javaeye.com/topic/799827" style="color:red"&gt;已有 &lt;strong&gt;5&lt;/strong&gt; 人发表回复，猛击-&amp;gt;&amp;gt;&lt;strong&gt;这里&lt;/strong&gt;&amp;lt;&amp;lt;-参与讨论&lt;/a&gt;
      &lt;/span&gt;
      &lt;br&gt;&lt;br&gt;&lt;br&gt;
</code></pre>

<p><span style="color:#e28822">JavaEye推荐</span>
<br></p>

<ul><li><a href="http://www.iteye.com/clicks/433"><span style="color:red;font-weight:bold">—软件人才免语言低担保 赴美带薪读研！— </span></a></li></ul>


<p><br><br><br></p>

</div>


            <div class="footer">
              <div class="contact">
                <p>
                  Your Name<br />
                  What You Are<br />
                  your@email.com
                </p>
              </div>
              <div class="contact">
                <p>
                  <a href="http://github.com/lyuehh/">github.com/lyuehh</a><br />
                  <a href="http://twitter.com/lyuehh/">twitter.com/lyuehh</a><br />
                </p>
              </div>
            </div>
          </div>
        </div> <!-- /container -->

    </body>
</html>
