---
layout: post
title:  "【译文】Z：一种基于Z-表达式的新语言"
date:   2013-01-03 16:00:00
author: 
categories: program
---

## 【译文】Z：一种基于Z-表达式的新语言
### by 
### at 2013-01-03 16:00:00
### original <http://www.soimort.org/posts/132>

<p>Original Article: <a href="http://chrisdone.com/z/">A tiny language called Z</a> by <a href="http://chrisdone.com/">Chris Done</a><br>
(Chinese Translation by <a href="http://www.soimort.org/">Mort Yao</a>)</p>

<hr>

<h2>翻译君的话</h2>

<p>为了给了解一些Lisp的人节省时间：<strong>你可以把Z看成是Scheme在另一个平行宇宙里的镜像</strong>——Scheme程序由<a href="http://en.wikipedia.org/wiki/S-expression">S-表达式（S-expression）</a>构成，而Z的基本元素则是<strong>Z-表达式（Z-expression）</strong>。Z-表达式与S-表达式的不同之处在于，它通过<strong>缩进</strong>而不是<strong>括号嵌套</strong>来表示其语义。如果你知道了这些，就可以直接去hack它了：</p>

<p><a href="https://github.com/chrisdone/z">https://github.com/chrisdone/z</a></p>

<p>（注意：该项目虽然名字叫Z，但是和由Zermelo集合论衍生而来的<a href="http://en.wikipedia.org/wiki/Z_notation">Z符号语言</a>似乎并无直接联系。）</p>

<p>以前有个笑话：据说某俄国特工经过九死一生偷到了NASA的太空火箭发射程序的源代码的最后一页，代码是</p>
<div><pre><code>)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
</code></pre></div>
<p>现在，如果你厌倦了Lisp里面太多的括号，不妨去尝试一下Z！</p>

<p>这个由Chris Done发起的项目比较新（2013年1月1日，也就是前几天刚发布）。查了一下Scheme的历史，发现采用缩进来代替括号的想法早在十年前（2003年）就有人在<a href="http://en.wikipedia.org/wiki/Scheme_Requests_for_Implementation">SRFI（Scheme Request For Implementation）</a>上面提出过了（<a href="http://srfi.schemers.org/srfi-49/srfi-49.html">SRFI-49: Indentation-sensitive syntax</a>）。当时用的名称叫做<a href="http://en.wikipedia.org/wiki/M-expression#Variants">I-表达式（I-expression）</a>。不过这个想法并没有被Scheme社区广泛接受。不知道这次新出现的Z前景如何，拭目以待。</p>

<p>此外，如果你做过传说中的<a href="http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours">48小时写一个Scheme解释器（Write Yourself a Scheme in 48 Hours）</a>的话，你会发现这个<a href="https://github.com/chrisdone/z">Z解释器的实现</a>基本上是与它平行的。把以前实现的Scheme解释器改写成Z解释器应该也不是什么难事。玩的只是概念而已。</p>

<p>以下为原文内容。</p>

<hr>

<h2>一种叫做Z的小型语言</h2>

<p>一种小型的、严格的、非纯函数式的、<a href="http://www.haskell.org/haskellwiki/Currying">柯里式的（curried）</a>、动态类型的（尽管这可能会在将来改变）、<a href="http://en.wikipedia.org/wiki/Partial_application">分步代入的（partially applied）</a>且有着相当奇特语法的语言。</p>

<p><em>它的基本思想看起来很聪明，甚至聪明得有些过头了。 — 摘自reddit的评论</em></p>

<h3>从Markdown得到的启发</h3>

<p>首先，让我们回顾一下Markdown。即使你没有亲自写过Markdown，你应该也已经见到过一些。你应该知道在Markdown的语法中有一个特别之处，即它嵌入代码的方式。它极其简单；不过是：<strong>你只需缩进4个空格，然后就可以随心所欲地在后面书写任何代码了！</strong></p>
<div><pre><code>Hello world! Here comes some code!

    Here is some arbitrary code! f.x()/f23(); // Zaha!

And now we&#39;re back to normal text...
</code></pre></div>
<p>这个想法的特别之处，就是你事实上可以把任何东西都放到这个缩进的后面，而且，它们不会影响到外围的代码！这是个非常牛逼的想法，让我来告诉你为什么。</p>

<h3>Z-表达式（Z-expression）</h3>

<p>我将在此介绍一个极其微型的语言，称之为“Z”，用来展示我的这一想法。</p>

<p>Z有着极其、极其简单的语法。古怪，却简单。这里是它如何工作的一个例子，函数的调用采取如下形式：</p>
<div><pre><code>name argument
</code></pre></div>
<p>更深入些的话，下面这段代码：</p>
<div><pre><code>foo bar mu zot
</code></pre></div>
<p>实际上是被分组后依次解析的：</p>
<div><pre><code>foo (bar (mu zot))
</code></pre></div>
<p>（注意：在Z源码里实际上并没有括号。Z即Zero。）</p>

<p>如果仔细想一想前面给出的<code>name argument</code>形式的话，这其实是一个非常自然的分组方式。</p>

<p>为了向某个函数传递多个参数，额外的参数需要被放置在下一行，并且被统一缩进到与第一个参数所在的同一列。</p>
<div><pre><code>foo bar
    mu
    zot
</code></pre></div>
<p>这表明<code>foo</code>函数有三个参数。该规则适用于<strong>任何场合</strong>，因此，我们也可以写：</p>
<div><pre><code>foo bar mu
        zot
    bob
</code></pre></div>
<p>这表明<code>foo</code>函数有两个参数，而<code>bar</code>函数有两个参数。</p>

<p>我管这种形式叫做“Z-表达式（Z-expression）”。Lisp语言是括弧状的（curly），卷曲的（curvy），它有它的S-表达式（S-expressions）。而Z则是锯齿状的（jagged），犀利的（sharp）。以及，古怪的。</p>

<p>特殊算符遵循一套相同的规则。下面我将介绍其中的一些特殊算符。</p>

<h3>Z的内置算符</h3>

<p><code>defun</code>特殊算符需要两个参数：一个名称的列表，其中第一个表示函数的名称；以及一个函数体。这里是一个用来<strong><em>连接</em></strong>两个列表的函数：</p>

<pre><code><span>defun</span> ap x y
      ++ x
         y
</code></pre>

<p>所有的Z函数都是柯里式的（curried）和<a href="http://en.wikipedia.org/wiki/Partial_application">分步代入（partially applied）</a>的，如同在Haskell中一样。故上述代码等效于：</p>

<pre><code><span>def</span> ap
    <span>fn</span> x
       <span>fn</span> y
          ++ x
             y
</code></pre>

<p>在本介绍中暂时不对此加以赘述。我们同样有<code>if</code>和<code>do</code>：</p>

<pre><code><span>if</span> foo
   bar
   mu

<span>do</span> this
   that
   those
</code></pre>

<p>如果你感兴趣的话，注意下，这些特殊算符采取一种非函数的<a href="http://en.wikipedia.org/wiki/Normal_order_evaluation#Normal_order">常序式求值策略（Normal-order evaluation）</a>。它们只是单纯从语法上来解释自身的参数！</p>

<p>我们同样有一些用于表示数字的诸如<code>123</code>、用于表示字符串的诸如<code>&quot;strings&quot;</code>和<code>unit</code>之类的符号，就和nothing、null、empty、voidness、niente一样稀松平常<em>（翻译君：这些是各种用来表示“空”的词汇）</em>。</p>

<h3>定义宏</h3>

<p>啊哈！La pièce de résistance（法语：主盘大菜上桌，即全套大餐的精华）！现在，我们将拥有一个<code>defmacro</code>算符，它的任务是允许我们自行定义新的符号。看好了……</p>

<pre><code><span>defmacro</span> -- _
         <span>"unit"</span>
</code></pre>

<p>Voilà（法语：瞧这）！我们定义了一个名称<code>--</code>，它取得一个我们并不关心其内容的参数<code>_</code><em>（翻译君：在这里下划线的含义与许多语言中相同，表示无名变量）</em>，并且总是返回字符串<code>&quot;unit&quot;</code>。</p>

<p>所有的宏都读取一个字符串，这个字符串是源码中所有可以成为它参数的部分，而我们知道，这部分将由缩进来决定。所有的宏都将会产生一个新的字符串，被用来置换到调用宏的原位置，然后将会被解释器<strong><em>重新解析</em></strong>。</p>

<p>在我们的这个<code>--</code>宏的例子当中，我们仅仅返回了一个<code>unit</code>，一个<a href="http://en.wikipedia.org/wiki/NOP">非操作符（no-op）</a>。这样，我们就<strong>已经定义了属于我们自己的注释符号</strong>：</p>

<pre><code><span>-- A simple function, that is used inside the macro below.</span>
<span>defmacro</span> ap x y
         ++ x
            y
</code></pre>

<p>挞哒（Tada）！这是一个带注释的函数定义！用到了我们刚才自创的注释语法，不是吗！我们同样也可以把这个函数<code>ap</code>用在其它的宏的<strong><em>内部</em></strong>，这在Lisp语言中是非常典型的用法。所以现在，就让我们基于它来定义一个稍微复杂一些的宏吧：</p>

<h3><code>when</code>宏</h3>

<pre><code><span>-- A messy macro (because it uses string manipulation),
   but demonstrates the idea well enough.</span>
<span>defmacro</span> when input
         <span>fn</span> blocks
            ap <span>"if"</span>
               ++ <span>z:indent-before</span> 3
                                  car blocks
                  ++ <span>"\n"</span>
                     ++ <span>z:indent</span> 3
                                 car cdr blocks
                        ++ <span>"\n"</span>
                           <span>z:indent</span> 3
                                    <span>"unit"</span>
            <span>z:blocks</span> input
</code></pre>

<p>这里可以看到，我们提供了一些辅助函数，用以获取“blocks”——也就是一次函数代入中的全部参数——并将它们传递给从<code>fn blocks</code>开始的匿名函数，然后构造出一个用于返回的字符串。</p>

<p>你能看出这个宏的目的吗？有了它，我们就可以写出：</p>

<pre><code>when = 1
       1
     print ++ <span>"The number is: "</span>
              when true
                   show 123
</code></pre>

<p>看看这是多么自然？在宏当中嵌套宏什么的完全不是问题！</p>

<h3>字符串的宏</h3>

<p>在编程时经常会遇到的问题是，如何尽可能避免麻烦地书写字符串。通常情况下，我们得遵循一套字符转义的特殊规则。但在Z中，你完全不需要这么做！</p>

<p>以前字符串的使用方式都弱爆了：</p>

<pre><code>print <span>"Hai, guys!"</span>
</code></pre>

<p>我们将要定义一个新的宏来方便我们书写字符串，那就是<code>:</code>符号。它旨在让字符串同正常人类语言一样直接可读，并且允许你在缩进后的文本列范围内不受任何限制地书写任意文本。</p>

<pre><code><span>defmacro</span> : input
         <span>z:string</span> input
</code></pre>

<p>以上，我提供了一种将一个<code>string</code>转换成一个<code>&quot;string&quot;</code>的方法，因此不管把任何东西作为<code>input</code>传递到宏，都将被逐字返回，并且是以字符串的形式。准备好了吗？请看！</p>

<pre><code><span>-- Example with print:</span>
print : Hello, World!
        What's going on in here? 
</code></pre>

<p>果然碉堡了不是么？它看起来就像是一段常见的脚本程序！而<strong><em>这</em></strong>，也正是从Markdown那里得到的启发。它同样也适用于在其他函数中的代入：</p>

<pre><code><span>defun</span> message msg
      <span>do</span> print : Here's a message
         print msg
         print : End of message. 
</code></pre>

<p>可以如此使用上述定义的函数：</p>

<pre><code>message ap : Hello,
           ++ <span>" World! "</span>
              : Love ya! 
</code></pre>

<p>只要你愿意，当然也可以直接这么写：</p>

<pre><code>message : <span>Everybody dance now!</span>
</code></pre>

<h3>一些函数定义的示例</h3>

<p>到目前为止已经足够给力了。让我们从兴奋中暂时缓口气，来看一些枯燥的纯函数。这些就是Z代码真实的样子。</p>

<pre><code><span>-- Map function.</span>
<span>defun</span> map f xs
      <span>if</span> unit? xs
         unit
         cons f car xs
              map f
                  cdr xs

<span>-- ["foo","bar"] → foo\nbar\n</span>
<span>defun</span> unlines xs
      <span>if</span> unit? xs
         <span>""</span>
         ++ car xs
            ++ <span>"\n"</span>
               unlines cdr xs

<span>-- Take the first n elements of list xs.</span>
<span>defun</span> take n xs
      <span>if</span> = n
           0
         unit
         <span>if</span> unit? xs
            unit
            cons car xs
                 take - n
                        1
                      cdr xs

<span>-- Take all but the last element of a list.</span>
<span>defun</span> init xs
      <span>if</span> unit? xs
         unit
         <span>if</span> unit? cdr xs
            unit
            cons car xs
                 init cdr xs

<span>-- Take the last element of a list, or return a default.</span>
<span>defun</span> last def xs
      <span>if</span> unit? xs
         def
         <span>if</span> unit? cdr xs
            car xs
            last def
                 cdr xs
</code></pre>

<p>话说，没有模式匹配（pattern matching）的编程不是很蛋疼吗！？不幸的是，今天我们暂时不会在这里用Z去定义一套模式匹配符，因为要实现一个像模像样的模式匹配并非轻易之举，而做一个过于简陋的会让我感觉很囧。<em>（翻译君：囧rz）</em></p>

<p>我们可以开始使用这些函数了，正如所期望的那样：</p>

<pre><code><span>-- Print the blocks of foo and bar with ! on the end.</span>
print unlines map <span>fn</span> x
                     ++ x
                        <span>"!"</span>
                  <span>z:blocks</span> : foo
                             bar

<span>-- Use of take function.</span>
print unlines take 3
                   <span>z:blocks</span> : foo
                              bar
                              mu
                              zot
</code></pre>

<h3>正则表达式</h3>

<p>这是另外一个简单的宏的实际用途：正则表达式！让我们来亲身体验一下。</p>

<p>我们的标准库中最基本的正则函数是<code>regex:match</code>和<code>regex:new</code>。<code>regex:match</code>返回一个所有匹配正则表达式<code>(foo)</code>的列表（list）。</p>

<pre><code>print regex:match regex:new <span>"(abc)"</span>
                  <span>"abc"</span>
</code></pre>

<p>到目前为止我们已经算得上是宏的<strong><em>高玩</em></strong>了，所以，来看看更漂亮的写法是什么样的：</p>

<pre><code><span>defun</span> ~~ regex string
      regex:match regex
                  string

print ~~ regex:new <span>"(def)"</span>
         <span>"defghi"</span>
</code></pre>

<p>元芳，你怎么看？还不错吧？至少要做一个字符串匹配所需的代码变得更短了。不过构造正则表达式的语法仍然显得有些笨重。让我们来创建一个宏！</p>

<pre><code><span>defmacro</span> rx input
         ++ <span>"regex:new "</span>
            <span>z:string</span> input

print ~~ rx <span>Age: (.*)</span>
         <span>"Age: 123"</span>
</code></pre>

<p>稍微美观了些，但是还算不上<strong><em>碉堡</em></strong>。</p>

<p>我们或许可以跳过整个构造正则表达式的部分，把它与匹配的部分合并：</p>

<pre><code><span>defmacro</span> ~ input
         <span>fn</span> blocks
            ++ <span>"~~ rx"</span>
               ++ <span>z:indent-before</span> 6
                                  unlines init blocks
                  ++ <span>"\n"</span>
                     <span>z:indent</span> 3
                              last <span>""</span>
                                   blocks
            <span>z:blocks</span> input

print ~ <span>Age: (.*)</span>
        <span>"Age: 666"</span>
</code></pre>

<p><strong><em>现在</em></strong>我们才算是真正完成了屌丝的逆袭！这语法看起来就像是从矮穷挫瞬间变成了高富帅有木有！</p>

<pre><code>print ~ <span>Age: (.*)</span>
        <span>([a-z]+)</span>
        <span>"Age: 777\nlalala"</span>
</code></pre>

<p>更加高能的是，你甚至可以把正则表达式分开在多行写。卧槽，既然这么给力，再来和正则战个痛又如何？</p>

<pre><code>print ~ <span>Age: (.*)</span>
        <span>([a-z]+)</span>
        : <span>Age: 999</span>
          <span>beep!</span>
</code></pre>

<p>当然，它也可以与其它的宏在一起搭配使用。<del>管他后面这句话是什么意思反正翻译君是不想翻了。</del></p>

<h3>代码编辑</h3>

<p>Z-表达式的另外一个撸点是，对它进行文本编辑几乎毫无鸭梨。试问：你如何才能在Lisp或者其他类似语言中找到当前语义节点的起始和终止位置？</p>

<div><pre><code><span>(</span><span>lorem</span> <span>ipsum-lorem-ipsum</span> <span>()</span>
  <span>(</span><span>foo-bar</span><span>)</span>
  <span>(</span><span>let* </span><span>((</span><span>zot</span> <span>(</span><span>biff-pop</span><span>))</span>
         <span>(</span><span>zar-zar</span> <span>(</span><span>beep</span> <span>&quot;%s.bill&quot;</span> <span>bob</span><span>)))</span>
    <span>(</span><span>if </span><span>(</span><span>ben-bill-bocky</span> <span>doo-dar</span><span>)</span>
        <span>(</span><span>let*|</span> <span>((</span><span>foo</span> <span>(</span><span>foo-bar-mu-zot</span><span>))</span>
               <span>(</span><span>bar</span> <span>(</span><span>ipsum-lorem</span><span>))</span>
               <span>(</span><span>ipsum</span> <span>(</span><span>cdr </span><span>(</span><span>assoc </span><span>&#39;cakes</span> <span>lorem</span><span>)))</span>
               <span>(</span><span>lorem</span> <span>(</span><span>cdr </span><span>(</span><span>assoc </span><span>&#39;potato</span> <span>lorem</span><span>)))</span>
               <span>(</span><span>ipsum</span> <span>(</span><span>cdr </span><span>(</span><span>assoc </span><span>&#39;ipsum</span> <span>lorem</span><span>)))</span>
               <span>(</span><span>lorem</span> <span>(</span><span>cdr </span><span>(</span><span>assoc </span><span>&#39;lorem</span> <span>lorem</span><span>))))</span>
          <span>(</span><span>if </span><span>bob</span>
              <span>(</span><span>progn</span>
                <span>(</span><span>bill</span> <span>ben</span><span>)</span>
                <span>(</span><span>the</span> <span>cake</span> <span>is</span> <span>a</span> <span>lie</span><span>)</span>
                <span>(</span><span>the</span> <span>game</span><span>))</span>
            <span>(</span><span>message</span> <span>&quot;Structural integrity is not secured.&quot;</span><span>)))</span>
      <span>(</span><span>message</span> <span>&quot;Data, because it&#39;s polite.&quot;</span> <span>cakes</span><span>))))</span>
</code></pre></div>

<p>如果你的光标刚好处在<code>let</code>之后，你会怎样做？老套路。你开始搜寻一个标志着起始的左括号。你找到了它。然后你开始向后移，搜寻一个标志结束的右括号。每次当遇到一个左括号，你把它压入栈中。每次当遇到一个右括号，你把它从栈中弹出。一旦遇到了一个字符串的开始，或者是转义字符序列，你将需要等待再次遇到下一个非转义字符，然后继续……呃，你开始感到乏味了吗？其实我也这么想。我以为我能轻易地办到这件事情，但事实上并非如此。<em>（翻译君：Emacs下难道没有方便定位Lisp代码的插件吗？我什么都不知道……）</em></p>

<p>在Z中，一切都变得如此简单。你只需找到起始的列，根据第一个非空格字符的位置。然后上下移动光标，找到与其缩进的起始列位置不同的行，那就是当前语义块起始或终止之处。你将拥有整个Z-表达式。想要移动它？小菜一碟，只需要剪切和粘贴、之后根据偏移增添或删减前置空格即可。担心缩进风格？在Z中它算不上什么问题。就像不存在缩进风格这回事一样。Z自始至终只有一种缩进方式。</p>

<h3>未来的工作</h3>

<h4>反引号（Quasiquotations）</h4>

<p>若不借鉴前人的历史，我们必将一事无成。Lisp有着悠久的历史，它教给了我们引号和反引号，以及借助于它们来处理字符串是多么便捷。我同意这一点。这就是为什么在下一步，我打算实现这样的语法：</p>

<pre><code><span>defmacro</span> when cond body
         <span>`</span> if <span>,</span> cond
              <span>,</span> body
              unit
</code></pre>

<p>当然，它遵从与所有Z-表达式相同的语法模式，但却与Lisp具有相同的语义。无论如何，这仅仅只是一个语法糖而已。Z的真正威力体现在它通过缩进来划分代码的语义区域上。</p>

<h4>“数学”宏</h4>

<p>在Z中，你使用多参数函数时需要用到缩进。这在做某些数学计算的时候多少有些蛋疼，因为数学表达式的参数通常只是一些简单的、同序的子表达式。考虑到这一点，拥有一套数学宏是完全必要的。例如，<code>#</code>：</p>

<pre><code><span>def</span> x # x²-y²×(2xy+x²-y²×(2xy+c))
</code></pre>

<p>为什么不呢？<em>（翻译君数死早，没看出来这个式子是要干啥= =）</em></p>

<hr>

<h2>安装入门</h2>

<h3>实现</h3>

<p><a href="https://github.com/chrisdone/z">这里</a>是Z的官方解释器。</p>

<h4>安装</h4>

<p>Z解释器当前使用Haskell实现。你可以在<a href="http://www.haskell.org/platform/">这里</a>下载Haskell。</p>

<p>Haskell安装完成后，编译Z的解释器：<em>（翻译君：你可能需要自行用包管理器安装<a href="http://hackage.haskell.org/package/text">text</a>和<a href="http://hackage.haskell.org/package/parsec">parsec</a>）</em></p>
<div><pre><code>$ cd &lt;path/to/z/dir&gt;
$ ghc Setup.hs
$ ./Setup configure
$ ./Setup build
</code></pre></div>
<p>生成的二进制文件位于<code>dist/build/z/z</code>。</p>

<p>运行它，可以交互式地对Z语句进行求值。</p>

<p>若要执行一个完整的Z源文件，可以通过管道：</p>
<div><pre><code>$ ./dist/build/z/z &lt; examples.zz
</code></pre></div>