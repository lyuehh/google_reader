---
layout: post
title:  "函数式编程很难，这正是你要学习它的原因"
date:   2012-07-31 12:13:38
author: 
categories: program
---

## 函数式编程很难，这正是你要学习它的原因
### by 
### at 2012-07-31 12:13:38
### original <http://kb.cnblogs.com/page/118598/>

<p style="text-align:center"><span><img src="http://pic001.cnblogs.com/images/2012/1/2012073111533493.png" alt=""><br></span></p><p><span>　　<strong>英文原文</strong>：</span><a href="http://dave.fayr.am/posts/2011-08-19-lets-go-shopping.html">Functional Programming Is Hard,That's Why It's Good</a></p><p>　　很奇怪不是，很少有人每天都使用函数式编程语言。如果你用Scala, Haskell, Erlang,F#或某个Lisp方言来编程，很可能没有公司会花钱聘你。这个行业里的绝大部分人都是使用像Python, Ruby, Java或C#等面向对象的编程语言，它们用起来很顺手。不错，你也许会偶然用到一两个函数式语言特征，例如block，但人们不会去做函数式编程。</p><p>　　然而，很多年来，我们一直被教导说函数式编程语言很好很棒。我仍然记得当我第一次阅读ESR的著名的关于学习Lisp语言的论文时的困惑。也许大多数的人对Paul Graham 的《<a href="http://www.paulgraham.com/avg.html">Beating The Averages</a>》这篇文章更加熟悉：</p><blockquote><p>使用Lisp开发使我们的开发周期迭代的如此之快，以至于有时当竞争对手在新闻发布会上推出他们的新功能一两天后，我们就能复制出同样的功能。当报道产品发布的新闻记者打电话给我们时，我们的产品已经拥有了同样的功能特征。</p></blockquote><p>　　那些皈依函数式编程的人中，一直常见的考虑是：学习这种新的、函数式的语言对你有好处；就像是某些人建议说每天30分钟的健身房活动会让你的身体健康一样。但这也同时暗示了这样做的难度和需要的付出。Lisp语言跟Haskell、Ocaml和Scala语言不同，被认为是出了名的难学，可以说是臭名昭著。文雅的人说这是Lisp语言的深度&amp;广度的体现。不文雅的人说这是意淫或玩弄学术或简单的没必要。我认为，它的难度跟你对它熟不熟悉有关，而且，这种难度是一种重要指标显示：学习这样的一种语言会让你编程更有效率、能力更强。</p><p><strong>　　它给你的初次印象不友善</strong></p><p>　　我7岁时就开始编程，在漫长无聊的郊区夏季里，在我祖父的计算机上瞎搞一气。我学了BASIC，用它在屏幕上画一个蹦跳的球。我学了Pascal，用它写了一个能通过PC喇叭放音乐的程序。大概10岁时我学了C语言，但遇到了一堵越不过去的墙，直到我上了高中。那就是：指针。即使不算这些该死的指针，我写、读、学习、练习中，同样遭遇无数的失败。我把祖父的硬盘给毁掉了两次(一次属意外)，最后弄得不少次要自己重装操作系统。我失败，一遍遍的失败。</p><p>　　也许你也有跟我相似的故事，也许是完全不同的一个。但我想，差不多所有学过编程的人都有过遇到困难的经历。我们在学了一些基本知识后，必然会遇到一些公认的概念上的关口，比如指针。很多计算机科学教授会把指针描述为他们课程上的过滤网。如果你想成为一名优秀的程序员，你必须要能理解指针。很少人能轻松的掌握它们。大多数人，包括我，则需要不断的练习和参考例子来理解什么是指针、为什么它们很重要。</p><p>　　这种艰难的努力过程不是偶然的，是一种几乎普遍的现象。指针是一种非常强大和基础功能的概念。学会它能让你成为一名更好的程序员，能让你的思考更加形象化。即使你使用的语言并不提供指针这样的特征，但跟指针类似的数据结构和概念却随处可见。</p><p><strong>　　新奇事物</strong></p><p>　　一旦你学会了几种语言后，所有的语言都开始看起来都很相似。知道Python的人学习Ruby可能不会遇到太多的问题，知道Java的人学习C#会感到很熟悉。不错，也有意外的地方。Ruby爱好者在学习Python时会对它的comprehension感到吃惊，Java用户会对C#里的委托摸不着头脑。还是那句话，如果你只瞟一眼，它们都很相似。我可以打保票的说，如果你还不曾有过这样的认识，一旦你学了一种Lisp语言，你会发现所有的Lisp变种都很相似。</p><p>　　有人说，大部分人第一次使用Haskell或Ocaml时都完全的不知所措。见鬼了，在Haskell里，连分号都跟别人不一样。这并不是语法的问题；Haskell和ML语言完全基于一种不同的概念、一种新的语言范式。你需要用不同的方式开发应用，不同的方式组织应用，不同的方式扩展应用。</p><p>　　很多这样的新概念都具有不可思议的强大力量。Haskell里的Monads是跟指针一样基础且强大的概念(你很可能在不知道它叫什么的情况下就已经使用过它们了)。所以，跟学了Java后再学C#不一样，有志向学习函数式语言的人需要往回走的更远，去学习更加基础的概念后才能接下去学习。就像是完全再学习一次指针。并且，就像是当年我们刚开始学习编程一样，一些很大的概念看起来会让人迷惑茫然，让人沮丧，直到你去攻克(以及失败)它们。</p><p><strong>　　吃下你的药丸，找到你的药剂师</strong></p><p>　　尽管不好学，但我坚信，学习这些函数式编程语言会在职业上对你有好处。我相信有些人读到这点时会眼睛翻起来向天看，很难想象出这些monoids或monad会对他们在使用Java或C#时有用处。对我而言，我已经不惊奇于由于这样的思维而阻止他们学习函数式语言的现象；他们需要学习一种跟指针和递归一样基础的新概念。他们需要有一种只有专业人员在完成清晰的商业目标时才具有的耐心和斗志。很少人能在过了可塑的年龄后还受得了一次又一次的挫折，否则我们现在都早成专家了，不是吗？</p><p>　　还有更复杂的东西，有大量的语言和算法研究都是用函数式语言实施的(尤其是Haskell)。你很容易会被这些不熟悉的概念例如分类学理论， half-finished abstractions，一些失败的研究弄的迷失方向。没有一个清晰的指导(比如由一个实用主义的作者写的一本好书)，本来已经很困难的学习任务变的更加可怕。</p><p>　　这些叠加起来的复杂因素导致了不出意外的结果：很多人不情愿在函数式编程学习中投入时间。很容易理解这种不情愿，我干嘛不把花在学习这些东西的时间用在实现什么东西上呢？但这种思路也表明了你永远不愿意在任何新技术上浪费时间(只用自己熟悉的)。在一个像软件技术这样日新月异的产业里，我不认为这是正确的判断。</p><p><strong>　　眼见为实</strong></p><p>　　学习一种函数式编程语言最显而易见的好处是，你能学会这种类型语言中的函数式概念。它能帮助你的大脑，让它具有能非常清晰的思考和处理一些惊人的重大概念的能力。这并不是函数式编程具有魔法；各种语言和范式的出现都是为了应对某一特定类别的问题。函数式编程的杀手锏正是应对了当今世界上日益增长的并行性编程和元数据编程趋势。</p><p>　　例如，我们研究一个简化的、本地版本化的Google著名的MapReduce范例。用函数式方式描述这种范例是不可思议的清晰简洁：</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><pre>mapReducer data partitioner mapper reducer =<br>              let partitions = partitioner data<br>              <span style="color:#0000ff">in</span> reduce reducer (map mapper partitions)</pre></div><p>　　让这样的代码支持并行计算或分布式并行计算是轻而易举的(对于本地并行计算，很多的功能包都支持pmap和preduce只需要利用函数式语言的一些简单特性)。像maps, partitions, generators, streams, reductions, folds, 已以及 function chaining等概念在各种的函数式编程语言中都大同小异，所以，任何对Lisp, Haskell, OCaml，甚至带点函数式语言特征的语言Python和Ruby熟悉的人，都会很容易的理解这里面的思想精华。</p><p>　　让我们花点时间考虑一下，如何用一种面向对象的语言，以一种常见的面向对象的模式来清楚的描述这种架构。至少你需要做的事情是定义用来描述mapper和reducer的声明。如果你有好奇心，请试着用你喜欢的面向对象语言描述一个最小化的面向对象的MapReduce。我发现那是非常罗嗦的。如果使用Java风格的语言，它会像这样：</p><div style="background-color:#f5f5f5;border:1px solid #cccccc;padding:10px"><pre><span style="color:#0000ff">interface</span> Mapper {<br>   B map(A input);<br> }<br><br> <span style="color:#0000ff">interface</span> Reducer {<br>   Y reduce(X a, X b);<br> }<br><br> <span style="color:#0000ff">abstract</span> <span style="color:#0000ff">class</span> MapReduce {<br>   <span style="color:#0000ff">private</span> Mapper mapper;<br>   <span style="color:#0000ff">private</span> Reducer reducer;<br><br>   <span style="color:#0000ff">public</span> MapReduce(Mapper map, Reducer reduce) {<br>     <span style="color:#008000">//</span><span style="color:#008000"> ...</span><span style="color:#008000"><br></span>   }<br><br>   <span style="color:#0000ff">public</span> run(SeqenceType data) {<br>     <span style="color:#008000">//</span><span style="color:#008000"> ...</span><span style="color:#008000"><br></span>   }<br> }</pre></div><p>　　即使是没有加入循环逻辑，这种缺乏函数式模式中常见的名词和动词的使用，使得MapReduce这种技术很难被定义。这种定义方式几乎是滑稽可笑的，但它能让你想到函数式概念。另外一个好例子是Scala语言如何利用完备的<a href="http://gee.cs.oswego.edu/dl/papers/fj.pdf">Java Fork/Join 类库</a>，把它轻松的集成的自己的自有语法中。</p><p><strong>　　各有所求</strong></p><p>　　所以，我鼓励任何想进步的程序员：请考虑学习一种函数式语言。Haskell和OCaml都是极好的选择，F#和Erlang也相当的不错。它们都不好学，但也许这是个好事。努力弄清楚你遇到的复杂的概念，看看是否有其他人正在利用这些概念；经常的，你会在寻找这些不熟悉的概念的真正用意的时候实现思想上的突破。</p><p>　　当你开始学的时候，请注意，不要过于在意。就像其他任何需要你花时间和精力的事情一样，过度的在函数式编程上进行精力上的投资是很危险的。掉进了认知能力的陷阱后，你的投资会血本无归。你很容易会忘掉世界上还有无数种计算模型，你更容易忘掉有多少种优秀的软件根本没有使用任何的函数式概念。</p><p>　　学习的道路会越来越难走，但从另一方面说，在你日常的编程中，你会发现有越来越多的可以使用的重要概念和模型。对于这样紧凑的编程风格你会越来越适应，必然，你也会对如何成为一名更好的软件工程师有了新的认识。</p><p><strong>　　补充</strong></p><p>　　有不少校对这篇文章的人在看完文章后都问了我一个同样的问题：听起来不错，大卫，可是我应该学习那种语言呢？当然，这是他们给我出的难题。</p><p>　　我想，如果你是一个很有经验的程序员，这最能应付这个问题的答案是：选一种符合你的需求的。如果你需要在JVM上工作，选择Scala或Clojure。如果你想能快速的开发大型分布式软件系统，选择Erlang。如果你想要一种具有超强编译器的超能干活的语言，请选择Haskell或RCaml。如果你想要一种比Ruby或Python更有能力的原型工具，选择Scheme。</p><p>　　请记住，我们在这里要做这些的目的是为了实际的技能和自我进步。如果你能腾出时间学这些，就走出你的安逸环境，挑战自己。</p><p>　　因为我已经学习了Lisp和Erlang，而且使用OCaml做专业工作，我决定研究一下Haskell，这完全是另外一个世界。我发现唯一能帮助我参透这种语言的途径是依赖 <a href="http://learnyouahaskell.com/">Learn You A Haskell </a>和 <a href="http://book.realworldhaskell.org/">Real World Haskell</a> 这两本有用的指导材料。这些书写的非常好，很有价值，而且可以免费在网上找到。如果你想试一下Haskell，这些书可以当作你的寻宝图。</p>